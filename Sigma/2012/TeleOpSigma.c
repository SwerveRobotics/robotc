#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTServo,  none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     touchSensor,    sensorTouch)
#pragma config(Sensor, S3,     IRSensor,       sensorI2CCustom)
#pragma config(Motor,  mtr_S1_C1_1,     motorLeft,     tmotorNormal, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     motorRight,    tmotorNormal, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     motorArm,      tmotorNormal, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C2_2,     motorG,        tmotorNormal, openLoop)
#pragma config(Servo,  srvo_S1_C3_1,    fingerLeft,           tServoStandard)
#pragma config(Servo,  srvo_S1_C3_2,    fingerRight,          tServoStandard)
#pragma config(Servo,  srvo_S1_C3_3,    servoWrist,           tServoStandard)
#pragma config(Servo,  srvo_S1_C3_4,    servoIR,              tServoStandard)
#pragma config(Servo,  srvo_S1_C3_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"
#include "C:\ftc\drivers\2.3\drivers\HTIRS2-driver.h" //only used in autonomous

int deadZone = 30;

long wayTooLong = 1000;  // millisecond threshold for absolute stall
long tooLong = 250;  // millisecond threshod for partial stall
long sigMove = 75; // How many encoder ticks is a 'significant' movement

//variables used for stall code need to be initialized
int lastDirection[] = {0, 0, 0}; // Direction of last power -1 (reverse), 0 (stopped) or 1 (forward)
long timeLastSigMove[] = {0, 0, 0}; // Time last significant move occurred
long encLastSigMove[] = {0, 0, 0}; // Encoder reading at last significant move

int StallCode(tMotor motorSentTo, int wantedPower)
{
	int motorIndex;  //index value for the arrays we are storing values in.
	int direction = 0;
	switch(motorSentTo) //which motor power is being sent to
	{
		case motorLeft: // This is the name of one of the motors as referenced in the configuraiton.
			motorIndex = 0;
			break;
		case motorRight:
			motorIndex = 1;
			break;
		case motorArm:
			motorIndex = 2;
			break;
		default:
			break;
	}

	if (abs(wantedPower) < deadZone)  // Power below threshold, mark as stopped.
		direction = 0;
  else
  	direction = (wantedPower < 0) ? -1 : 1;

	if (direction == 0 || lastDirection[motorIndex] != direction)  // Stopped or changed direction.	Allow whatever power desired this time.
		{
    	lastDirection[motorIndex] = direction;
			timeLastSigMove[motorIndex]	 = time1[T1];
			encLastSigMove[motorIndex] = nMotorEncoder[motorSentTo];

			return wantedPower;
		}

 	lastDirection[motorIndex] = direction;

	if ( abs(encLastSigMove[motorIndex] - nMotorEncoder[motorSentTo]) > sigMove)  // Moved far enough to be considered significant, mark
		{
			timeLastSigMove[motorIndex]	= time1[T1];
			encLastSigMove[motorIndex] = nMotorEncoder[motorSentTo];

			return wantedPower;
		}

	if ( (time1[T1] - timeLastSigMove[motorIndex]) > wayTooLong )  // Time since last significant move too long, stalled
		{
			PlayTone(650,4);
			return 0;
		}

	if ( (time1[T1] - timeLastSigMove[motorIndex]) > tooLong )  // Time since last significant move too long, stalled
		{
			PlayTone(365,4);
			return wantedPower / 2;
		}

	return wantedPower;	// Haven’t moved far enough yet to be significant but haven’t timed out yet
}
//int motorSentTo;
/*long tooLong = 500;  // millisecond threshod for time to pass
long sigMove = 300; // How many encoder ticks is a 'significant' movement

//variables used for stall code need to be initialized
bool powerHasBeenOn[] = {false, false, false}; // True after significant power has been applied
long timeLastSigMove[] = {0, 0, 0}; // Time last significant move occurred
long encLastSigMove[] = {0, 0, 0}; // Encoder reading at last significant move

int StallCode(tMotor motorSentTo, int wantedPower)
{
	int motorIndex;  //index value for the arrays we are storing values in.
	switch(motorSentTo) //which motor power is being sent to
	{
		case motorLeft: // This is the name of one of the motors as referenced in the configuraiton.
			motorIndex = 0;
			break;
		case motorRight:
			motorIndex = 1;
			break;
		case motorArm:
			motorIndex = 2;
			break;
		default:
			break;
	}

	if (abs(wantedPower) < deadZone)  // Power below threshold, mark as no power.
		{
			powerHasBeenOn[motorIndex] = false;

			return wantedPower;
		}

	if (powerHasBeenOn[motorIndex] == false)  // Power transitioned above threshold, start monitoring power.	Allow whatever power desired this time.
		{
			powerHasBeenOn[motorIndex] = true;
			timeLastSigMove[motorIndex]	 = time1[T1];
			encLastSigMove[motorIndex] = abs(nMotorEncoder[motorSentTo]);

			return wantedPower;
		}

	if ( (abs( encLastSigMove[motorIndex] - nMotorEncoder[motorSentTo])) > sigMove)  // Moved far enough to be considered significant, mark
		{
			timeLastSigMove[motorIndex]	= time1[T1];
			encLastSigMove[motorIndex] = abs(nMotorEncoder[motorSentTo]);

			return wantedPower;
		}

	if ( (time1[T1] - timeLastSigMove[motorIndex]) > tooLong )  // Time since last significant move too long, stalled
		{
			PlayTone(724,5);
			return 0;
		}

	return wantedPower;	// Haven’t moved far enough yet to be significant but haven’t timed out yet
}*/


//variables used for stall code
/*long timeStalling[] = {0, 0, 0}; //amount of time the motors are stalling
long valueOfLastMove[] = {0, 0, 0}; //the value of the encoders when the motor last moved
long timeStoppedMoving[] = {0, 0, 0}; //the time the motors stopped

int StallCode(int motorSentTo, int wantedPower)
{
    int motorIndex;//index value for the arrays
    switch((tMotor)motorSentTo)//which motor power is being sent to
    {
    case motorLeft:
        motorIndex = 0;
        break;
    case motorRight:
        motorIndex = 1;
        break;
    case motorArm:
        motorIndex = 2;
        break;
    default:
        break;
    }
    long cur = nMotorEncoder[(tMotor)motorSentTo]; //current encoder value of motor
    //writeDebugStreamLine("%d", cur);

    if((wantedPower < -15 || wantedPower > 15)&&(cur == valueOfLastMove[motorIndex]))// the code is not entering this if statement in normal driving when encoders are not zeroed at the start of task main
    {
        if(timeStalling[motorIndex] + 150 >= time1[T1])// the code is not entering this if statement in normal driving when encoders are zeroed at the start of task main
        {
            if(timeStoppedMoving[motorIndex] == 0)
            {
                timeStoppedMoving[motorIndex] = time1[T1];
            }
            if(timeStoppedMoving[motorIndex] + 10 >= time1[T1])
            {
                writeDebugStreamLine("stall %d", motorIndex);
                PlayTone(724, 5);
                return wantedPower;
            }
            else
            {
                valueOfLastMove[motorIndex] = cur;
                timeStoppedMoving[motorIndex] = 0;
                timeStalling[motorIndex] = time1[T1];
            }
        }
        return wantedPower;
    }
    timeStalling[motorIndex] = time1[T1];
    return wantedPower;
}*/

void OpenHand()
{
    servo[fingerLeft] = 200;
    servo[fingerRight] = 50;
}

void CloseHand()
{
    servo[fingerLeft] = 100;
    servo[fingerRight] = 160;
}

task main()
{
    waitForStart(); // wait until FCS lets us go

    ClearTimer(T1);

    nMotorEncoder[motorLeft] = 0; //zero encoders
    nMotorEncoder[motorRight] = 0;

    nMotorEncoder[motorArm] = 0;
    nMaxRegulatedSpeed12V = 750;

    /*if(SensorValue(touchSensor) == 1)
    {
        nMotorEncoder[motorArm] = 0;
    }*/

    while(true) // infinite loop
    {
        getJoystickSettings(joystick);

        // slow mode
        if(joy1Btn(8) == 1) // if the lower left trigger is pressed on controller 1 ...
        {
            if(abs(joystick.joy1_y1) > deadZone) // and the left joystick value on controller 1 isn't in the deadzone ...
            {
                motor[motorLeft]  = StallCode(motorLeft, (joystick.joy1_y1) / 2); // set the left motor power to the left joystick value on controller 1 divided by 3
                //writeDebugStreamLine("left %d", nMotorEncoder[motorLeft]);
            }
            else
            {
                motor[motorLeft] = 0;//StallCode(motorLeft, 0); // if the left joystick value is in the deadzone set the left motor power to 0
            }

            if(abs(joystick.joy1_y2) > deadZone) // and the right joystick value on controller 1 isn't in the deadzone ...
            {
                motor[motorRight] = StallCode(motorRight, (joystick.joy1_y2) / 2); // set the right motor power to the right joystick value on controller 1 divided by 3
                //writeDebugStreamLine("right %d", nMotorEncoder[motorRight]);
            }
            else
            {
                motor[motorRight] = StallCode(motorRight, 0); // if the left joystick value is in the deadzone set the right motor power to 0
            }
        }
        else // regular mode
        {
            if(abs(joystick.joy1_y1) > deadZone) // if the left joystick value isn't in the deadzone ...
            {
                motor[motorLeft]  = StallCode(motorLeft, joystick.joy1_y1); // set the left motor power to the left joystick value on controller 1
            }
            else
            {
                motor[motorLeft] = StallCode(motorLeft, 0); // if the left joystick value is in the deadzone set the left motor power to 0
            }

            if(abs(joystick.joy1_y2) > deadZone) // if the right joystick value isn't in the deadzone ...
            {
                motor[motorRight] = StallCode(motorRight, joystick.joy1_y2); // set the right motor power to the right joystick value on controller 1
            }
            else
            {
                motor[motorRight] = StallCode(motorRight, 0); // if the left joystick value is in the deadzone set the right motor power to 0
            }
        }

        if(joy2Btn(8) == 1) // if lower right trigger on controller 2 is pressed
        {
            OpenHand();
        }
        else if(joy2Btn(6) == 1) // if upper right trigger on controller 2 is pressed
        {
            CloseHand();
        }

        if (joy2Btn(5) == 1)
        {
            while(nMotorEncoder[motorArm] < (1440 * 0.25))
            {
                motor[motorArm] = StallCode(motorArm, 75);
            }
        }

        if (joy2Btn(7) == 1)
        {
            // use dpad on second controller to control arm
            if(joystick.joy2_TopHat == 0) // if up on the dpad on controller 2 is pressed
            {
                motor[motorArm] = StallCode(motorArm, 35);
            }
            else if(joystick.joy2_TopHat == 4) // if down on the dpad on controller 2 is pressed
            {
                if(SensorValue(touchSensor) == 1)
                {
                    motor[motorArm] = StallCode(motorArm, 0);// if touch sensor is pressed and the arm is trying to go down, don't let the arm move
                    nMotorEncoder[motorArm] = 0;
                }
                else if(nMotorEncoder[motorArm] < 100)
                {
                    motor[motorArm] = StallCode(motorArm, -20);// arm goes down slowly
                }
                else
                {
                    motor[motorArm] = StallCode(motorArm, -35);// arm goes down
                }
            }
            // use joystick to control arm
            else if(joystick.joy2_y1 > 50) // if left joystick is up
            {
                motor[motorArm] = StallCode(motorArm, 35); // arm goes up
            }
            else if(joystick.joy2_y1 < -50) // if left joystick is down
            {
                if(SensorValue(touchSensor) == 1)
                {
                    motor[motorArm] = StallCode(motorArm, 0); // if touch sensor is pressed and the arm is trying to go down, don't let the arm move
                    nMotorEncoder[motorArm] = 0;
                }
                else if(nMotorEncoder[motorArm] < 100)
                {
                    motor[motorArm] = StallCode(motorArm, -20); // arm goes down slowly
                }
                else
                {
                    motor[motorArm] = StallCode(motorArm, -35);// arm goes down
                }
            }
            else // left joystick is in the middle
            {
                motor[motorArm] = StallCode(motorArm, 0); // arm doesn't move
            }
        }
        else
        {
            // use dpad on second controller to control arm
            if(joystick.joy2_TopHat == 0) // if up on the dpad on controller 2 is pressed
            {
                motor[motorArm] = StallCode(motorArm, 75);
            }
            else if(joystick.joy2_TopHat == 4) // if down on the dpad on controller 2 is pressed
            {
                if(SensorValue(touchSensor) == 1)
                {
                    motor[motorArm] = StallCode(motorArm,0);// if touch sensor is pressed and the arm is trying to go down, don't let the arm move
                    nMotorEncoder[motorArm] = 0;
                }
                else if(nMotorEncoder[motorArm] < 100)
                {
                    motor[motorArm] = StallCode(motorArm, -20);// arm goes down slowly
                }
                else
                {
                    motor[motorArm] = StallCode(motorArm, -75);// arm goes down
                }
            }
            // use joystick to control arm
            else if(joystick.joy2_y1 > 50) // if left joystick is up
            {
                motor[motorArm] = StallCode(motorArm, 75); // arm goes up
            }
            else if(joystick.joy2_y1 < -50) // if left joystick is down
            {
                if(SensorValue(touchSensor) == 1)
                {
                    motor[motorArm] = StallCode(motorArm, 0); // if touch sensor is pressed and the arm is trying to go down, don't let the arm move
                    nMotorEncoder[motorArm] = 0;
                }
                else if(nMotorEncoder[motorArm] < 100)
                {
                    motor[motorArm] = StallCode(motorArm, -20); // arm goes down slowly
                }
                else
                {
                    motor[motorArm] = StallCode(motorArm, -75);// arm goes down
                }
            }
            else // left joystick is in the middle
            {
                motor[motorArm] = StallCode(motorArm, 0); // arm doesn't move
            }
        }
        int pos = joystick.joy2_y2;
        /* (pos < 0)
        {
        pos = 0;
        }*/
        // use right joystick on second controller to control wrist
        servo[servoWrist] = 255 - (pos * (256 / 128)) - 20;
        //writeDebugStreamLine("%d", 255 - (pos * (256 / 128)));
    }
}
