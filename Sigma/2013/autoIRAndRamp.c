#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  HTServo)
#pragma config(Sensor, S2,     sensorIR,       sensorHiTechnicIRSeeker1200)
#pragma config(Motor,  mtr_S1_C1_1,     motorBL,       tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     motorFL,       tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     motorFR,       tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_2,     motorBR,       tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C3_1,     motorArm,      tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_2,     motorFlag,     tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C4_1,    servoFR,              tServoStandard)
#pragma config(Servo,  srvo_S1_C4_2,    servoBR,              tServoStandard)
#pragma config(Servo,  srvo_S1_C4_3,    servoBL,              tServoStandard)
#pragma config(Servo,  srvo_S1_C4_4,    servoFL,              tServoStandard)
#pragma config(Servo,  srvo_S1_C4_5,    servoWrist,           tServoStandard)
#pragma config(Servo,  srvo_S1_C4_6,    servoRoller,          tServoContinuousRotation)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c";

float degToServo = (255.0/192.0); // converts degrees into servo values

task main()
{
	waitForStart();

	nMotorEncoder[motorFR] = 0; // zero front right motor encoder

	// set servos to go sideways
	servo[servoFL] = 0;
	servo[servoFR] = 0;
	servo[servoBL] = 0;
	servo[servoBR] = 0;
	wait1Msec(500);

	while(SensorValue(sensorIR) != 4) // go sideways until IR beacon
	{
		motor[motorFL] = 100;
		motor[motorFR] = 100;
		motor[motorBL] = 100;
		motor[motorBR] = 100;
	}
	// stop motors
	motor[motorFL] = 0;
	motor[motorFR] = 0;
	motor[motorBL] = 0;
	motor[motorBR] = 0;

	// place cube with arm
	wait1Msec(500);

	while(nMotorEncoder[motorFR] < (1440 * 4)) // go sideways until there's space to move around the ramp
	{
		motor[motorFL] = 100;
		motor[motorFR] = 100;
		motor[motorBL] = 100;
		motor[motorBR] = 100;
	}
	// stop motors
	motor[motorFL] = 0;
	motor[motorFR] = 0;
	motor[motorBL] = 0;
	motor[motorBR] = 0;

	// turn servos to default
	servo[servoFL] = 90 * degToServo;
	servo[servoFR] = 90 * degToServo;
	servo[servoBL] = 90 * degToServo;
	servo[servoBR] = 90 * degToServo;
	wait1Msec(200);

	nMotorEncoder[motorFR] = 0; // zero front left motor encoder

	// go forward until there's space to get onto ramp
	while(nMotorEncoder[motorFR] < (1440 * 3))
	{
		motor[motorFL] = 100;
		motor[motorFR] = 100;
		motor[motorBL] = 100;
		motor[motorBR] = 100;
	}
	// stop motors
	motor[motorFL] = 0;
	motor[motorFR] = 0;
	motor[motorBL] = 0;
	motor[motorBR] = 0;

	// turn servos sideways
	servo[servoFL] = 0;
	servo[servoFR] = 0;
	servo[servoBL] = 0;
	servo[servoBR] = 0;
	wait1Msec(200);

	// go onto ramp
	while(nMotorEncoder[motorFR] > -1440)
	{
		motor[motorFL] = -100;
		motor[motorFR] = -100;
		motor[motorBL] = -100;
		motor[motorBR] = -100;
	}
	// stop motors
	motor[motorFL] = 0;
	motor[motorFR] = 0;
	motor[motorBL] = 0;
	motor[motorBR] = 0;
}
