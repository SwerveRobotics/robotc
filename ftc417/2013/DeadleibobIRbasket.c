#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  none)
#pragma config(Hubs,  S2, HTServo,  HTServo,  none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     ,               sensorI2CMuxController)
#pragma config(Sensor, S3,     IRseeker,       sensorHiTechnicIRSeeker1200)
#pragma config(Motor,  mtr_S1_C1_1,     RightMotor,    tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     Right2,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     LeftMotor,     tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C2_2,     Left2,         tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_1,     HookLifter,    tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_2,     Flag,          tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S2_C1_1,    GearChanger,          tServoStandard)
#pragma config(Servo,  srvo_S2_C1_2,    Flipper,              tServoStandard)
#pragma config(Servo,  srvo_S2_C1_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S2_C1_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S2_C1_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S2_C1_6,    servo6,               tServoNone)
#pragma config(Servo,  srvo_S2_C2_1,    servo7,               tServoNone)
#pragma config(Servo,  srvo_S2_C2_2,    servo8,               tServoNone)
#pragma config(Servo,  srvo_S2_C2_3,    servo9,               tServoNone)
#pragma config(Servo,  srvo_S2_C2_4,    servo10,              tServoNone)
#pragma config(Servo,  srvo_S2_C2_5,    servo11,              tServoNone)
#pragma config(Servo,  srvo_S2_C2_6,    servo12,              tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.C";
//int IRvalue;
int distancetoIR;

bool isbasketbasket4;
int deadZone = 15;


//stall code (ends on line 96)
long wayTooLong = 1000;  // millisecond threshold for absolute stall
long tooLong = 350;  // millisecond threshod for partial stall
long sigMove = 100; // How many encoder ticks is a 'significant' movement

//variables used for stall code need to be initialized
int lastDirection[] = {0, 0, 0, 0}; // Direction of last power -1 (reverse), 0 (stopped) or 1 (forward)
long timeLastSigMove[] = {0, 0, 0, 0}; // Time last significant move occurred
long encLastSigMove[] = {0, 0, 0, 0}; // Encoder reading at last significant move

int StallCode(tMotor motorSentTo, int wantedPower)
{
	int motorIndex;  //index value for the arrays we are storing values in.
	int direction = 0;
	switch(motorSentTo) //which motor power is being sent to
	{
		case LeftMotor: // This is the name of one of the motors as referenced in the configuraiton.
			motorIndex = 0;
			break;
		case RightMotor:
			motorIndex = 1;
			break;
		/*case ForkLift:
			motorIndex = 2;
			break;*/
		default:
			break;
	}

	if (abs(wantedPower) < deadZone)  // Power below threshold, mark as stopped.
		direction = 0;
  else
  	direction = (wantedPower < 0) ? -1 : 1;

	if (direction == 0 || lastDirection[motorIndex] != direction)  // Stopped or changed direction.	Allow whatever power desired this time.
		{
    	lastDirection[motorIndex] = direction;
			timeLastSigMove[motorIndex]	 = time1[T1];
			encLastSigMove[motorIndex] = nMotorEncoder[motorSentTo];

			return wantedPower;
		}

 	lastDirection[motorIndex] = direction;

	if ( abs(encLastSigMove[motorIndex] - nMotorEncoder[motorSentTo]) > sigMove)  // Moved far enough to be considered significant, mark
		{
			timeLastSigMove[motorIndex]	= time1[T1];
			encLastSigMove[motorIndex] = nMotorEncoder[motorSentTo];

			return wantedPower;
		}

	if ( (time1[T1] - timeLastSigMove[motorIndex]) > wayTooLong )  // Time since last significant move too long, stalled
		{
			PlayTone(650,4);
			return 0;
		}

	if ( (time1[T1] - timeLastSigMove[motorIndex]) > tooLong )  // Time since last significant move too long, stalled
		{
			PlayTone(365,4);
			return wantedPower / 2;
		}

	return wantedPower;	// Haven’t moved far enough yet to be significant but haven’t timed out yet
}
//end of stall code-------------------------------------------------------------------------------
//------------------------------------------------------------------------------------------------
//------------------------------------------------------------------------------------------------
//------------------------------------------------------------------------------------------------
//------------------------------------------------------------------------------------------------
//------------------------------------------------------------------------------------------------
//------------------------------------------------------------------------------------------------
//------------------------------------------------------------------------------------------------
//------------------------------------------------------------------------------------------------
//------------------------------------------------------------------------------------------------
//------------------------------------------------------------------------------------------------
//------------------------------------------------------------------------------------------------
//------------------------------------------------------------------------------------------------
//------------------------------------------------------------------------------------------------

task main()
{

	servo[Flipper] = 0;
	servo[GearChanger] = 0;
	waitForStart();

	nMotorEncoder[LeftMotor] = 0;
	nMotorEncoder[RightMotor] = 0;

	//goes to basket 4
	while (nMotorEncoder[LeftMotor] > -1050)
	{
		motor[LeftMotor] = StallCode(LeftMotor, (-85));
		motor[Left2] = StallCode(LeftMotor, (-85));
		motor[RightMotor] = StallCode(RightMotor, (-85));
		motor[Right2] = StallCode(RightMotor, (-85));
	}
		motor[LeftMotor] = StallCode(LeftMotor,   (0));
		motor[Left2] = StallCode(LeftMotor,       (0));
		motor[RightMotor] = StallCode(RightMotor, (0));
		motor[Right2] = StallCode(RightMotor,     (0));

		//if basket 4 is IR then it flips
	if (SensorValue[IRseeker] == 5)
	{
		wait1Msec(1000);
		servo[Flipper] = 224;
		wait1Msec(9000);
		servo[Flipper] = 0;
		wait1Msec(1500);

		//adjust distance to be positive and slightly smaller
		distancetoIR = nMotorEncoder[LeftMotor];
		distancetoIR = distancetoIR * - 1;
		distancetoIR = distancetoIR - 1000;

		//reset motors and encoders
		nMotorEncoder[LeftMotor] = 0;
		nMotorEncoder[RightMotor] = 0;

		motor[LeftMotor] = StallCode(LeftMotor, (0));
		motor[Left2] = StallCode(LeftMotor, (0));
		motor[RightMotor] = StallCode(RightMotor, (0));
		motor[Right2] = StallCode(RightMotor, (0));

			//goes back to wall
		while (nMotorEncoder[LeftMotor] < distancetoIR)
		{
		motor[LeftMotor] = StallCode(LeftMotor, (55));
		motor[Left2] = StallCode(LeftMotor, (55));
		motor[RightMotor] = StallCode(RightMotor, (55));
		motor[Right2] = StallCode(RightMotor, (55));
		}

		motor[LeftMotor] = StallCode(LeftMotor, (0));
		motor[Left2] = StallCode(LeftMotor, (0));
		motor[RightMotor] = StallCode(RightMotor, (0));
		motor[Right2] = StallCode(RightMotor, (0));

		nMotorEncoder[LeftMotor] = 0;
		nMotorEncoder[RightMotor] = 0;

		//turns to block zone
		while (nMotorEncoder[LeftMotor] > -900)
		{
			motor[LeftMotor] = StallCode(LeftMotor, (-35));
			motor[Left2] = StallCode(LeftMotor, (-35));
		}
		nMotorEncoder[LeftMotor] = 0;
		nMotorEncoder[RightMotor] = 0;

		//drive towards block zone
		while (nMotorEncoder[LeftMotor] < 3000)
		{
			motor[LeftMotor] = StallCode(LeftMotor, (35));
			motor[Left2] = StallCode(LeftMotor, (35));
			motor[RightMotor] = StallCode(RightMotor, (35));
			motor[Right2] = StallCode(RightMotor, (35));
		}
		motor[LeftMotor] = StallCode(LeftMotor, (0));
		motor[Left2] = StallCode(LeftMotor, (0));
		motor[RightMotor] = StallCode(RightMotor, (0));
		motor[Right2] = StallCode(RightMotor, (0));

		nMotorEncoder[LeftMotor] = 0;
		nMotorEncoder[RightMotor] = 0;

		//turn towards ramp
		while (nMotorEncoder[LeftMotor] > -450)
		{
			motor[LeftMotor] = StallCode(LeftMotor, (-35));
			motor[Left2] = StallCode(LeftMotor, (-35));
			motor[RightMotor] = StallCode(RightMotor, (35));
			motor[Right2] = StallCode(LeftMotor, (35));
		}
		motor[LeftMotor] = StallCode(LeftMotor, (0));
		motor[Left2] = StallCode(LeftMotor, (0));
		motor[RightMotor] = StallCode(RightMotor, (0));
		motor[Right2] = StallCode(RightMotor, (0));

		nMotorEncoder[LeftMotor] = 0;
		nMotorEncoder[RightMotor] = 0;


		//drive onto ramp
		while (nMotorEncoder[LeftMotor] < 3700)
		{
			motor[LeftMotor] = StallCode(LeftMotor, (100));
			motor[Left2] = StallCode(LeftMotor, (100));
			motor[RightMotor] = StallCode(RightMotor, (100));
			motor[Right2] = StallCode(RightMotor, (100));
		}
		motor[LeftMotor] = StallCode(LeftMotor, (0));
		motor[Left2] = StallCode(LeftMotor, (0));
		motor[RightMotor] = StallCode(RightMotor, (0));
		motor[Right2] = StallCode(RightMotor, (0));
		//stops program
		return;
		}

		//if not basket 4 then...

	//goes to basket 3
	while (nMotorEncoder[LeftMotor] > -800)
	{
		motor[LeftMotor] = StallCode(LeftMotor, (-35));
		motor[Left2] = StallCode(LeftMotor, (-35));
		motor[RightMotor] = StallCode(RightMotor, (-35));
		motor[Right2] = StallCode(RightMotor, (-35));
	}

		motor[LeftMotor] = StallCode(LeftMotor, (0));
		motor[Left2] = StallCode(LeftMotor, (0));
		motor[RightMotor] = StallCode(RightMotor, (0));
		motor[Right2] = StallCode(RightMotor, (0));

		//decides if basket 3 is IR
		if (SensorValue[IRseeker] == 5)
		{

		servo[Flipper] = 75;
		wait1Msec(1500);
		servo[Flipper] = 0;
		wait1Msec(1500);

			distancetoIR = nMotorEncoder[LeftMotor];
			distancetoIR = distancetoIR * -1;
			distancetoIR = distancetoIR - 1000;
			nMotorEncoder[LeftMotor] = 0;

		//goes back to wall
		while (nMotorEncoder[LeftMotor] < distancetoIR)
		{
		motor[LeftMotor] = StallCode(LeftMotor, (35));
		motor[Left2] = StallCode(LeftMotor, (35));
		motor[RightMotor] = StallCode(RightMotor, (35));
		motor[Right2] = StallCode(RightMotor, (35));
		}

		nMotorEncoder[LeftMotor] = 0;
		nMotorEncoder[RightMotor] = 0;

		motor[LeftMotor] = StallCode(LeftMotor, (0));
		motor[Left2] = StallCode(LeftMotor, (0));
		motor[RightMotor] = StallCode(RightMotor, (0));
		motor[Right2] = StallCode(RightMotor, (0));

		//turns towards block zone
		while (nMotorEncoder[LeftMotor] > -200)
		{
			motor[LeftMotor] = -35;
			motor[Left2] = -35;
		}
		nMotorEncoder[LeftMotor] = 0;

		//drive towards block zone
		while (nMotorEncoder[LeftMotor] < 2800)
		{
			motor[LeftMotor] = StallCode(LeftMotor, (35));
			motor[Left2] = StallCode(LeftMotor, (35));
			motor[RightMotor] = StallCode(RightMotor, (35));
			motor[Left2] = StallCode(LeftMotor, (35));
		}
		motor[LeftMotor] = StallCode(LeftMotor, (0));
		motor[Left2] = StallCode(LeftMotor, (0));
		motor[RightMotor] = StallCode(RightMotor, (0));
		motor[Right2] = StallCode(RightMotor, (0));

		nMotorEncoder[LeftMotor] = 0;
		nMotorEncoder[RightMotor] = 0;

		//turn towards ramp
		while (nMotorEncoder[LeftMotor] > -800)
		{
			motor[LeftMotor] = StallCode(LeftMotor, (-35));
			motor[Left2] = StallCode(LeftMotor, (-35));
			motor[RightMotor] = StallCode(RightMotor, (35));
			motor[Right2] = StallCode(RightMotor, (35));
		}
		motor[LeftMotor] = StallCode(LeftMotor, (0));
		motor[Left2] = StallCode(LeftMotor, (0));
		motor[RightMotor] = StallCode(RightMotor, (0));
		motor[Right2] = StallCode(RightMotor, (0));

		nMotorEncoder[LeftMotor] = 0;
		nMotorEncoder[RightMotor] = 0;

		//drive onto ramp
		while (nMotorEncoder[LeftMotor] < 3700)
		{
			motor[LeftMotor] = StallCode(LeftMotor, (100));
			motor[Left2] = StallCode(LeftMotor, (100));
			motor[RightMotor] = StallCode(RightMotor, (100));
			motor[Right2] = StallCode(RightMotor, (100));
		}
		motor[LeftMotor] = StallCode(LeftMotor, (0));
		motor[Left2] = StallCode(LeftMotor, (0));
		motor[RightMotor] = StallCode(RightMotor, (0));
		motor[Right2] = StallCode(RightMotor, (0));

		return;
		}
		//if basket 3 is not IR then...
		//goes to basket 2
	while (nMotorEncoder[LeftMotor] > 7160)
	{
		motor[LeftMotor] = StallCode(LeftMotor, (-35));
		motor[Left2] = StallCode(LeftMotor, (-35));
		motor[RightMotor] = StallCode(RightMotor, (-35));
		motor[Right2] = StallCode(RightMotor, (-35));
	}
		motor[LeftMotor] = StallCode(LeftMotor, (0));
		motor[Left2] = StallCode(LeftMotor, (0));
		motor[RightMotor] = StallCode(RightMotor, (0));
		motor[Right2] = StallCode(RightMotor, (0));

		//decides if basket 2 is IR basket
		if (SensorValue[IRseeker] == 5)
	{

		servo[Flipper] = 75;
		wait1Msec(1500);
		servo[Flipper] = 0;
		wait1Msec(1500);

		distancetoIR = nMotorEncoder[LeftMotor];
		distancetoIR = distancetoIR * -1;
		distancetoIR = distancetoIR - 1100;
		nMotorEncoder[LeftMotor] = 0;
		nMotorEncoder[RightMotor] = 0;

			//goes back to wall
		while (nMotorEncoder[LeftMotor] < distancetoIR)
		{
		motor[LeftMotor] = StallCode(LeftMotor, (35));
		motor[Left2] = StallCode(LeftMotor, (35));
		motor[RightMotor] = StallCode(RightMotor, (35));
		motor[Right2] = StallCode(RightMotor, (35));
		}

		motor[LeftMotor] = StallCode(LeftMotor, (0));
		motor[Left2] = StallCode(LeftMotor, (0));
		motor[RightMotor] = StallCode(RightMotor, (0));
		motor[Right2] = StallCode(RightMotor, (0));

		nMotorEncoder[LeftMotor] = 0;
		nMotorEncoder[RightMotor] = 0;

		//turns towards block zone
		while (nMotorEncoder[LeftMotor] > -300)
		{
			motor[LeftMotor] = StallCode(LeftMotor, (-35));
			motor[Left2] = StallCode(LeftMotor, (-35));
		}
		nMotorEncoder[LeftMotor] = 0;
		nMotorEncoder[RightMotor] = 0;

		//drives towards block zone
		while (nMotorEncoder[LeftMotor] < 3000)
		{
			motor[LeftMotor] = StallCode(LeftMotor, (35));
			motor[Left2] = StallCode(LeftMotor, (35));
			motor[RightMotor] = StallCode(RightMotor, (35));
			motor[Right2] = StallCode(RightMotor, (35));
		}
		motor[LeftMotor] = StallCode(LeftMotor, (0));
		motor[Left2] = StallCode(LeftMotor, (0));
		motor[RightMotor] = StallCode(RightMotor, (0));
		motor[Right2] = StallCode(RightMotor, (0));

		nMotorEncoder[LeftMotor] = 0;
		nMotorEncoder[RightMotor] = 0;

		//turns towards ramp
		while (nMotorEncoder[LeftMotor] > -800)
		{
			motor[LeftMotor] = StallCode(LeftMotor, (-35));
			motor[Left2] = StallCode(LeftMotor, (-35));
			motor[RightMotor] = StallCode(RightMotor, (35));
			motor[Right2] = StallCode(RightMotor, (35));
		}

		motor[LeftMotor] = StallCode(LeftMotor, (0));
		motor[Left2] = StallCode(LeftMotor, (0));
		motor[RightMotor] = StallCode(RightMotor, (0));
		motor[Right2] = StallCode(RightMotor, (0));

		nMotorEncoder[LeftMotor] = 0;
		nMotorEncoder[RightMotor] = 0;

		//drive onto ramp
		while (nMotorEncoder[LeftMotor] < 3700)
		{
			motor[LeftMotor] = StallCode(LeftMotor, (100));
			motor[Left2] = StallCode(LeftMotor, (100));
			motor[RightMotor] = StallCode(RightMotor, (100));
			motor[Right2] = StallCode(RightMotor, (100));
		}
		motor[LeftMotor] = StallCode(LeftMotor, (0));
		motor[Left2] = StallCode(LeftMotor, (0));
		motor[RightMotor] = StallCode(RightMotor, (0));
		motor[Right2]  =StallCode(RightMotor, (0));
		return;
	}

	//if basket 2 is not IR then...

	//goes to basket 1
	while (nMotorEncoder[LeftMotor] > -3000)
	{
		motor[LeftMotor] = StallCode(LeftMotor, (-35));
		motor[Left2] = StallCode(LeftMotor, (-35));
		motor[RightMotor] = StallCode(RightMotor, (-35));
		motor[Right2] = StallCode(RightMotor, (-35));
	}
		motor[LeftMotor] = StallCode(LeftMotor, (0));
		motor[Left2] = StallCode(LeftMotor, (0));
		motor[RightMotor] = StallCode(RightMotor, (0));
		motor[Right2] = StallCode(RightMotor, (0));

		servo[Flipper] = 75;
		wait1Msec(1500);
		servo[Flipper] = 0;
		wait1Msec(1500);

		distancetoIR = nMotorEncoder[LeftMotor];
		distancetoIR = distancetoIR * -1;
		distancetoIR = distancetoIR - 1100;

		nMotorEncoder[LeftMotor] = 0;
//2, 3, 5, 6
			//goes back to wall
		while (nMotorEncoder[LeftMotor] < distancetoIR)
		{
		motor[LeftMotor] = StallCode(LeftMotor, (35));
		motor[Left2] = StallCode(LeftMotor, (35));
		motor[RightMotor] = 35;
		motor[Right2] = StallCode(RightMotor, (35));
		}

		nMotorEncoder[LeftMotor] = 0;

		motor[LeftMotor] = StallCode(LeftMotor, (0));
		motor[Left2] = StallCode(LeftMotor, (0));

		while (nMotorEncoder[LeftMotor] > -100)
		{
			motor[LeftMotor] = StallCode(LeftMotor, (-35));
		}
		nMotorEncoder[LeftMotor] = 0;

		while (nMotorEncoder[LeftMotor] < 3100)
		{
			motor[LeftMotor] = StallCode(LeftMotor, (35));
			motor[RightMotor] = StallCode(RightMotor, (35));
		}
		motor[LeftMotor] = StallCode(LeftMotor, (0));
		motor[RightMotor] = StallCode(RightMotor, (0));

		nMotorEncoder[LeftMotor] = 0;

		while (nMotorEncoder[LeftMotor] > -800)
		{
			motor[LeftMotor] = StallCode(LeftMotor, (-35));
			motor[RightMotor] = StallCode(RightMotor, (35));
		}
		motor[LeftMotor] = StallCode(LeftMotor, (0));
		motor[RightMotor] = StallCode(RightMotor, (0));

		nMotorEncoder[LeftMotor] = 0;
		nMotorEncoder[RightMotor] = 0;

		while (nMotorEncoder[LeftMotor] < 3700)
		{
			motor[LeftMotor] = StallCode(LeftMotor, (100));
			motor[RightMotor] = StallCode(RightMotor, (100));
		}
		motor[LeftMotor] = StallCode(LeftMotor, (0));
		motor[RightMotor] = StallCode(RightMotor, (0));
		return;
	}
